/*
 *  @file  : ScdChecker.cpp
 *  @author: luteng
 *  @date  : 2015-06-17 14:01:58.533
 *  @note  : Generated by SlxTemplates
 */

#include "ScdChecker.h"
#include "CheckItems/XmlCheck.h"
#include "CheckItems/SchemaCheck.h"
#include "OutputMgr.h"
#include "CacheMgr.h"

using namespace std;

CScdChecker::CScdChecker()
    : m_scs(SCS_INITTING)
    , m_pVn(NULL)
    , m_nFileSize(0)
{
}

CScdChecker::~CScdChecker()
{
}

bool CScdChecker::SetFilePathToCheck(const char *lpFilePath)
{
    if (m_scs == SCS_INITTING)
    {
        AssignString(m_strFilePath, lpFilePath);
        m_scs = SCS_INITED;

        return true;
    }

    return false;
}

std::string CScdChecker::GetFilePathToCheck() const
{
    return m_strFilePath;
}

bool CScdChecker::RegisterCheckItem(CCheckItemBase *pCheckItem)
{
    if (m_scs == SCS_INITED || m_scs == SCS_INITTING)
    {
        m_mapCheckItems.insert(make_pair(pCheckItem->GetItemConfig().strCheckItemKey, pCheckItem));
        return true;
    }

    return false;
}

bool CScdChecker::CheckStart()
{
    if (m_scs != SCS_INITED)
    {
        return false;
    }

    m_scs = SCS_STARTTING;

    // 去除特殊检测项
    m_mapCheckItems.erase(CXmlCheck::GetInstance()->GetItemConfig().strCheckItemKey);
    m_mapCheckItems.erase(CSchemaCheck::GetInstance()->GetItemConfig().strCheckItemKey);

    // 输出题头
    COutputMgr::GetInstance()->Output(
        "<?xml version=\"1.0\" encoding=\"%s\"?>\r\n",
        COutputMgr::GetInstance()->GetOutputMode(OH_OUTPUT) == OC_UTF8 ? "utf-8" : "gbk");
    COutputMgr::GetInstance()->Output("<CheckResults version=\"1.0\" rvertion=\"1.0\">\r\n");

    m_scs = SCS_STARTED;
    return true;
}

bool CScdChecker::CheckAll()
{
    if (m_scs != SCS_STARTED)
    {
        return false;
    }

    m_scs = SCS_CHECKING;

    // 1、xml检测
    if (!CXmlCheck::GetInstance()->Check())
    {
        COutputMgr::GetInstance()->Error(
            "检测项目%s,%s时发生错误\r\n",
            CXmlCheck::GetInstance()->GetItemConfig().strCheckItemKey.c_str(),
            CXmlCheck::GetInstance()->GetItemConfig().strCheckItemName.c_str());
        return false;
    }

    // 判断xml检测是否成功完成
    if (GetExistingVtdNav() != NULL)
    {
        // 1.1、构建行号偏移量对应表
        if (!BuildRowNumberOffsetMap())
        {
            COutputMgr::GetInstance()->Error(
                "构建行号偏移量对应表%s,%s时发生错误\r\n",
                CSchemaCheck::GetInstance()->GetItemConfig().strCheckItemKey.c_str(),
                CSchemaCheck::GetInstance()->GetItemConfig().strCheckItemName.c_str());
            return false;
        }

        // 2、schema检测
        if (CSchemaCheck::GetInstance()->IsEnabled())
        {
            if (!CSchemaCheck::GetInstance()->Check())
            {
                COutputMgr::GetInstance()->Error(
                    "检测项目%s,%s时发生错误\r\n",
                    CSchemaCheck::GetInstance()->GetItemConfig().strCheckItemKey.c_str(),
                    CSchemaCheck::GetInstance()->GetItemConfig().strCheckItemName.c_str());
                return false;
            }
        }

        // 2.1 预构建缓存
        if (!CCacheMgr::GetInstance()->PreBuildCaches())
        {
            COutputMgr::GetInstance()->Error(
                "预构建缓存%s,%s时发生错误\r\n",
                CSchemaCheck::GetInstance()->GetItemConfig().strCheckItemKey.c_str(),
                CSchemaCheck::GetInstance()->GetItemConfig().strCheckItemName.c_str());
            return false;
        }

        // 3、其他检测
        for (map<string, CCheckItemBase *>::iterator it = m_mapCheckItems.begin(); it != m_mapCheckItems.end(); ++it)
        {
            CCheckItemBase *&pCheckItem = it->second;

            if (!pCheckItem->Check())
            {
                COutputMgr::GetInstance()->Error(
                    "检测项目%s,%s时发生错误\r\n",
                    pCheckItem->GetItemConfig().strCheckItemKey.c_str(),
                    pCheckItem->GetItemConfig().strCheckItemName.c_str());
                return false;
            }
        }
    }

    m_scs = SCS_CHECKED;
    return true;
}

bool CScdChecker::CheckEnd()
{
    if (m_scs != SCS_CHECKED)
    {
        return false;
    }

    m_scs = SCS_ENDDING;

    // 输出尾部
    COutputMgr::GetInstance()->Output("</CheckResults>\r\n");

    m_scs = SCS_ENDED;
    return true;
}

com_ximpleware::VTDNav *CScdChecker::GetExistingVtdNav() const
{
    return m_pVn;
}

void CScdChecker::SetExistingVtdNav(com_ximpleware::VTDNav *pVn)
{
    m_pVn = pVn;
}

int CScdChecker::CalcRowNumberFromOffset(int nOffset) const
{
    bm_type::right_const_iterator it = m_bimapRowNumberOffset.right.upper_bound(nOffset);

    if (it == m_bimapRowNumberOffset.right.begin())
    {
        return 1;
    }
    else
    {
        --it;
        return it->second;
    }
}

int CScdChecker::CalcOffsetAndSizeFromRowNumber(int nRowNumber, int *pSize) const
{
    bm_type::left_const_iterator it = m_bimapRowNumberOffset.left.find(nRowNumber);
    int nSize = -1;
    int nOffset = -1;

    if (it != m_bimapRowNumberOffset.left.end())
    {
        nOffset = it->second;
        ++it;

        if (it == m_bimapRowNumberOffset.left.end())
        {
            nSize = m_nFileSize - nOffset;
        }
        else
        {
            nSize = it->second - nOffset - 1;
        }
    }

    if (pSize != NULL)
    {
        *pSize = nSize;
    }

    return nOffset;
}

std::string CScdChecker::GetRowContentByOffset(int nOffset) const
{
    int nRowNumber = CalcRowNumberFromOffset(nOffset);

    if (nRowNumber >= 1)
    {
        return GetRowContentByRowNumber(nRowNumber);
    }

    return std::string();
}

std::string CScdChecker::GetRowContentByRowNumber(int nRowNumber) const
{
    int nSize = 0;
    int nOffset = CalcOffsetAndSizeFromRowNumber(nRowNumber, &nSize);

    if (nOffset >= 0)
    {
        return std::string((const char *)m_pVn->getXML() + nOffset, nSize);
    }

    return std::string();
}

bool CScdChecker::BuildRowNumberOffsetMap()
{
    const char *lpBuffer = (const char *)m_pVn->getXML();
    int nSize = m_nFileSize;

    m_bimapRowNumberOffset.clear();

    // 开始查找
    m_bimapRowNumberOffset.insert(bm_type::value_type(1, 0));
    int nLastRowNumber = 1;
    int nOffset = 0;

    for (; nOffset < nSize; nOffset += 1)
    {
        if (lpBuffer[nOffset] == '\n')
        {
            if (!m_bimapRowNumberOffset.insert(bm_type::value_type(++nLastRowNumber, nOffset + 1)).second)
            {
                return false;
            }
        }
    }

//     cout<<m_bimapRowNumberOffset.right.rbegin()->first<<endl;
//     cout<<m_bimapRowNumberOffset.right.rbegin()->second<<endl;
// 
//     for (bm_type::left_const_iterator it = m_bimapRowNumberOffset.left.begin(); it != m_bimapRowNumberOffset.left.end(); ++it)
//     {
//         if (it->first == 10000 ||
//             it->first == 20000 ||
//             it->first == 1000000 ||
//             it->first == 1100000 ||
//             it->first == 1200000 ||
//             it->first == 1300000 ||
//             it->first == 1400000 ||
//             it->first < 20 ||
//             it->first > 1411700)
//         {
//             cout<<it->first<<", "<<it->second<<endl;
//         }
//     }

//     VTDNav *pVn = GetExistingVtdNav();
// 
//     if (pVn == NULL)
//     {
//         return false;
//     }
// 
//     CScopedVtdNav vn(pVn);
// 
//     vn->toElement(ROOT);
// 
//     Long n1 = vn->getContentkFragment();
//     Long n2 = vn->getElementFragment();
//     UByte *lpBuffer = vn->getXML();
//     wchar_t *lp = (wchar_t *)lpBuffer;
//     char *lp2 = (char *)lpBuffer;
// 
//     int n11 = n1 & 0xffffffff;
//     int n12 = (n1 >> 32) & 0xffffffff;
//     int n21 = n2 & 0xffffffff;
//     int n22 = (n2 >> 32) & 0xffffffff;

    return true;
}

void CScdChecker::StoreSizeOfFileToCheck(int nSize)
{
    m_nFileSize = nSize;
}
